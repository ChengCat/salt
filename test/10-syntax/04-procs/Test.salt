-- Test syntax of procs.
-- TODO: add exec tests to use the bindings.
-- TODO: support nested procedures.
-- TODO: procedure calls
-- TODO: make 'proc Stmt' imply 'proc [] of Stmt'

-- declarations ---------------------------------------------------------------
term decl1 []: []
 = proc yield []

term decl2 [n: #Nat]: #Nat
 = proc yield n

-- term decl3 [n: #Nat]: [] ! #Console
--  = box proc
--         seq #console'print "hello";
--         end

-- term decl4 []: #Nat ! #Console
--  = box proc
--         seq #console'print "hello";
--         yield 5


-- sugar for the above.
-- proc decl1s []: #Nat
--  =      yield []

-- proc decl2s [n: #Nat]: []
--  =      yield n

-- proc decl3s [n: #Nat]: []! #Console
--  =      seq #console'print "hello";
--         end

-- proc decl4s []: #Nat ! #Console
--  =      seq #console'print "hello";
--         yield 5

-- sequencing -----------------------------------------------------------------
-- simple sequencing
-- proc seq1 []: []! #Console
--  =      seq #console'print "hello";
--         seq #console'print "world";
--         seq #console'print "derp";
--         end


-- let-binding ----------------------------------------------------------------
-- proc let1 [x: #Nat, y: #Nat]: #Nat
--  =      let a = #nat'add [x, y];
--         let b = #nat'add [a, a];
--         yield #nat'add [a, b]


-- cel-introduction -----------------------------------------------------------
-- TODO: allow type to be omitted, like with let bindings
-- proc cel1 [x: #Nat, y: #Nat]: #Nat
--  =      cel a: #Nat ← 4;
--         cel b: #Nat ← 5;
--         yield #nat'add [a, b]


-- nested procedures ----------------------------------------------------------
-- TODO: need to be able to bind the result of a nested procedure.
-- proc nest1 []: []! #Console
--  =      seq #console'print "good morning";
--         seq seq #console'print "hello";
--             seq #console'print "world";
--             end
--         end

--
-- proc nest2 []: []! #Console
--  =      seq #console'print "good morning";
--         seq seq #console'print "hello";
--             seq seq #console'print "world";
--                 end
--             end
--         end


-- when -----------------------------------------------------------------------
-- proc when1 [b: #Bool, x: #Nat, y: #Nat]: #Nat
--  =      when b then return x;
--         yield y

-- proc when2 [n: #Nat]: #Text ! #Console
--  =      when #nat'eq [n, 1] then return "one";
--         when #nat'eq [n, 2] then return "two";
--         when #nat'eq [n, 3] then return "three";
--         yield "dunno"

-- proc when3 [n: #Nat, m: #Nat]: #Text ! #Console
--  =      when #nat'eq [n, 1] then when #nat'eq [m, 1] then return "ones";;
--         when #nat'eq [m, 1] then return "ones";
--         when #nat'eq [n, 2] then return "two";
--         yield "whatever"


-- proc when4 [n: #Nat, m: #Nat]: #Text ! #Console
--  =      when #nat'eq [n, 1] then
--             when #nat'eq [m, 1] then return "one, one";
--             when #nat'eq [m, 2] then return "one, two";
--             end;
--         when #nat'eq [n, 2]      then return "two";
--         yield "whatever"


-- case statements ------------------------------------------------------------
-- TODO: end missing a value.
-- TODO: also do form with 'case' as term at end.
-- proc case1 [v: <foo: #Nat, bar: #Nat>]: #Nat
--  =      case v of
--          { foo [x: #Nat] → return x
--          ; bar [x: #Nat] → return x };
--         end


-- Statement case does not need to be exhaustive as in the case of no match
-- control continues to the next statement.
-- proc case2 [v: <foo: #Nat, bar: #Nat>]: #Nat
--  =      case v of
--          { foo [x: #Nat] → return x };
--         end


-- proc case3 [v: <foo: #Nat, bar: [#Bool, #Nat, #Nat], baz: #Nat>]: #Nat
--  =      case v of
--          { foo [x: #Nat] → return x
--          ; bar [b: #Bool, x: #Nat, y: #Nat]
--            → if b then return x;
--              return y
--          ; baz [x: #Nat] → return x };
--         end


-- loop statements ------------------------------------------------------------
-- proc loop1 [n: #Nat]: []! #Console
--  =      loop
--             if #nat'gt [n, 10] then return [];
--             seq #console'print "hello"
--             end;
--         end




