-- Test syntax of procs.
-- TODO: add exec tests to use the bindings.

-- declarations ---------------------------------------------------------------
term decl1 []: []
 = proc yield []

term decl2 [n: #Nat]: #Nat
 = proc yield n

term decl3 [n: #Nat]: [] ! #Console
 = box proc
        seq call #console'print "hello";
        end

term decl4 []: #Nat ! #Console
 = box proc
        seq call #console'print "hello";
        yield [5]


-- sugar for the above.
proc decl1s []: #Nat
 =      yield [4]

proc decl2s [n: #Nat]: []
 =      yield []

-- TODO: if drop effect annotation should get error.
proc decl3s [n: #Nat]: []! #Console
 =      seq call #console'print "hello";
        yield []

proc decl4s []: #Nat ! #Console
 =      seq call #console'print "hello";
        yield 5


-- yield ----------------------------------------------------------------------
term yield1 [x: #Nat]: #Nat
 = proc yield [x]


-- call -----------------------------------------------------------------------
-- TODO: make 'call' keyword implicit.
term call1 [x: #Nat]: #Nat
 = proc call #nat'add [x, x]


-- sequencing -----------------------------------------------------------------
-- simple sequencing
proc let1 [x: #Nat, y: #Nat]: #Nat
 =      seq a = yield 2;
        seq b = yield 3;
        yield #nat'add [a, b]

-- sugar where the vector of bindings is assumed to be empty.
proc seq1 []: []! #Console
 =      seq call #console'print "hello";
        seq call #console'print "world";
        seq call #console'print "derp";
        end

-- nested procedure.
proc seq'nest1 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq call #console'print "world";
            end;
        end

-- doubly nested procedure.
proc seq'nest2 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq seq call #console'print "world";
                end;
            end;
        end

-- as above, but with implicit process end.
proc seq'nest3 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq seq call #console'print "world"


-- cell-introduction ----------------------------------------------------------
-- TODO: allow type to be omitted, like with let bindings
proc cell1 [x: #Nat, y: #Nat]: #Nat
 =      cell a: #Nat ← 4;
        cell b: #Nat ← 5;
        yield #nat'add [a, b]


-- cell update ----------------------------------------------------------------
-- TODO: make 'update' keyword implicit.
proc update1 [x: #Nat, y: #Nat]: #Nat
 =      cell a: #Nat ← x;
        update a ← y;
        yield a


-- when -----------------------------------------------------------------------
proc when1 [b: #Bool, x: #Nat, y: #Nat]: #Nat
 =      when b then return 5 done;
        yield y


proc when2 [n: #Nat]: #Text ! #Console
 =      when #nat'eq [n, 1] then return "one" done;
        when #nat'eq [n, 2] then return "two" done;
        when #nat'eq [n, 3] then return "three" done;
        yield "dunno"


proc when3 [n: #Nat, m: #Nat]: #Text ! #Console
 =      when #nat'eq [n, 1] then
                when #nat'eq [n, 2] then
                        return "derp"
                done
        done;
        yield "whatever"


proc when4 [n: #Nat, m: #Nat]: #Text ! #Console
 =      when #nat'eq [n, 1] then
                when #nat'eq [m, 1] then
                        return "one, one"
                done;
                when #nat'eq [m, 2] then
                        return "one, two"
                done
        done;
        yield "whatever"


proc when5 [n: #Nat, m: #Nat]: #Text ! #Console
 =      when { #nat'eq [n, 1]
                → when  { #nat'eq [m, 1] → return "one, one"
                        ; #nat'eq [m, 2] → return "one, two" } };
        yield "whatever"


-- match ----------------------------------------------------------------------
-- match does not need to be exhaustive because if we don't have
-- and alt for the given value we continue to the rest of the procedure.
proc match2 [v: <foo: #Nat, bar: #Nat>]: #Nat
 =      match v with
         { foo [x: #Nat] → return x };
        yield [5]


-- TODO: if the alts are exhaustive then the cont. is dead code,
-- so we shouldn't need to provide the result value.
proc match1 [v: <foo: #Nat, bar: #Nat>]: #Nat
  =      match v with
          { foo [x: #Nat] → return x
          ; bar [x: #Nat] → return x };
         yield [5]


proc match3 [v: <foo: #Nat, bar: [#Bool, #Nat, #Nat], baz: #Nat>]: #Nat
 =      match v with
         { foo [x: #Nat] → return x
         ; bar [b: #Bool, x: #Nat, y: #Nat]
           → when b then return x done;
             return y
         ; baz [x: #Nat] → return x };
        yield 0


-- loop -----------------------------------------------------------------------
proc loop1 [n: #Nat]: []! #Console
 =      loop    when #nat'gt [n, 10]
                        then return []
                done;
                call #console'print "hello"
        done


-- proc foo
--  =   enter   start []
--      with  { start [x]    = seq call fac [2, 3]; end
--            ; final []     = leave
--            };
--      seq call derp
--      yield [5]
--
--



