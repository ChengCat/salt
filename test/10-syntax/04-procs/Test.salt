-- Test syntax of procs.
-- TODO: add exec tests to use the bindings.
-- TODO: support nested procedures.
-- TODO: procedure calls
-- TODO: make 'proc Stmt' imply 'proc [] of Stmt'

-- declarations ---------------------------------------------------------------
term decl1 []: []
 = proc yield []

term decl2 [n: #Nat]: #Nat
 = proc yield n

term decl3 [n: #Nat]: [] ! #Console
 = box proc
        seq call #console'print "hello";
        yield []

term decl4 []: #Nat ! #Console
 = box proc
        seq call #console'print "hello";
        yield [5]


-- sugar for the above.
proc decl1s []: #Nat
 =      yield [4]

proc decl2s [n: #Nat]: []
 =      yield []

-- TODO: if drop effect annotation should get error.
proc decl3s [n: #Nat]: []! #Console
 =      seq call #console'print "hello";
        yield []

proc decl4s []: #Nat ! #Console
 =      seq call #console'print "hello";
        yield 5


-- yield ----------------------------------------------------------------------
term yield1 [x: #Nat]: #Nat
 = proc yield [x]


-- call -----------------------------------------------------------------------
term call1 [x: #Nat]: #Nat
 = proc call #nat'add [x, x]


-- sequencing -----------------------------------------------------------------
-- simple sequencing
proc let1 [x: #Nat, y: #Nat]: #Nat
 =      seq a = yield 2;
        seq b = yield 3;
        yield #nat'add [a, b]

-- sugar where the vector of bindings is assumed to be empty.
proc seq1 []: []! #Console
 =      seq call #console'print "hello";
        seq call #console'print "world";
        seq call #console'print "derp";
        yield []

-- nested procedure.
proc seq'nest1 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq call #console'print "world";
            yield [];
        yield []

-- doubly nested procedure.
proc seq'nest2 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq seq call #console'print "world";
                yield [];
            yield [];
        yield []


-- cell-introduction ----------------------------------------------------------
-- TODO: allow type to be omitted, like with let bindings
proc cell1 [x: #Nat, y: #Nat]: #Nat
 =      cell a: #Nat ← 4;
        cell b: #Nat ← 5;
        yield #nat'add [a, b]


-- cell update ----------------------------------------------------------------
proc update1 [x: #Nat, y: #Nat]: #Nat
 =      cell a: #Nat ← x;
        update a ← y;
        yield a



-- when -----------------------------------------------------------------------
-- proc when1 [b: #Bool, x: #Nat, y: #Nat]: #Nat
--  =      when b then return x;
--         yield y

-- proc when2 [n: #Nat]: #Text ! #Console
--  =      when #nat'eq [n, 1] then return "one";
--         when #nat'eq [n, 2] then return "two";
--         when #nat'eq [n, 3] then return "three";
--         yield "dunno"

-- proc when3 [n: #Nat, m: #Nat]: #Text ! #Console
--  =      when #nat'eq [n, 1] then when #nat'eq [m, 1] then return "ones";;
--         when #nat'eq [m, 1] then return "ones";
--         when #nat'eq [n, 2] then return "two";
--         yield "whatever"


-- proc when4 [n: #Nat, m: #Nat]: #Text ! #Console
--  =      when #nat'eq [n, 1] then
--             when #nat'eq [m, 1] then return "one, one";
--             when #nat'eq [m, 2] then return "one, two";
--             end;
--         when #nat'eq [n, 2]      then return "two";
--         yield "whatever"


-- case statements ------------------------------------------------------------
-- TODO: end missing a value.
-- TODO: also do form with 'case' as term at end.
-- proc case1 [v: <foo: #Nat, bar: #Nat>]: #Nat
--  =      case v of
--          { foo [x: #Nat] → return x
--          ; bar [x: #Nat] → return x };
--         end


-- Statement case does not need to be exhaustive as in the case of no match
-- control continues to the next statement.
-- proc case2 [v: <foo: #Nat, bar: #Nat>]: #Nat
--  =      case v of
--          { foo [x: #Nat] → return x };
--         end


-- proc case3 [v: <foo: #Nat, bar: [#Bool, #Nat, #Nat], baz: #Nat>]: #Nat
--  =      case v of
--          { foo [x: #Nat] → return x
--          ; bar [b: #Bool, x: #Nat, y: #Nat]
--            → if b then return x;
--              return y
--          ; baz [x: #Nat] → return x };
--         end


-- loop statements ------------------------------------------------------------
-- proc loop1 [n: #Nat]: []! #Console
--  =      loop
--             if #nat'gt [n, 10] then return [];
--             seq #console'print "hello"
--             end;
--         end




