
-- Primitive Values -----------------------------------------------------------
test type.unit          #unit

test type.bool'true     #true
test type.bool'true2    #bool'true
test type.bool'false    #true
test type.bool'false2   #bool'false

test type.nat1          1
test type.nat1234       1234

-- TODO: ints
-- test type.int           1i

test type.symbol        'Foo
test type.symbol2       'Bar1234


-- Term vector ----------------------------------------------------------------
test type.vec           [1, 2, 3]
test type.void          []


-- Term abstraction -----------------------------------------------------------
test type.abs           λ[x: #Bool] → x
test type.abs2          λ[x: #Bool, y: #Nat] → x
test type.abs3          λ[x: #Bool, y: #Nat] → [x, y]
test type.abs4          λ[x: #Bool, y: #Nat] → []
test type.abs5          λ[] → []


-- Type abstraction -----------------------------------------------------------
test type.abst'id       (λ@[a: #Data] → λ[x: a] → x)
test type.abst'id2      (λ@[a: #Data] [x: a] → x)
test type.abst'app      (λ@[a: #Data, b: #Data] [f: a → b, x: a] → f x)


-- Term/Term application ------------------------------------------------------
test type.appm'not      #bool'not [#true]
test type.appm'and      #bool'and [#true, #false]

test type.appm'lam      (λ[x: #Bool] → x) [#true]

test type.appm'lam2     (λ[f: #Bool → #Bool, x: #Bool] → f x)
                                [λ[x: #Bool] → [x], #true]

test type.appm'vec      (λ[x: #Bool, y: #Bool] → y)
                                ((λ[x: #Bool] → [x, x]) [#true])


-- Term/Type application ------------------------------------------------------
test type.appt'double   (λ@[a: #Data] [x: a] → [x, x]) @[#Nat] [5]

test type.appt'app      (λ@[a: #Data, b: #Data] [f: a → b, x: a] → f x)
                                @[#Bool, #Bool] [#bool'not, #true]


-- Let bindings ---------------------------------------------------------------
test type.let'fst       let [x, y] = (λ[x: #Bool] → [x, 5]) [#true]; x
test type.let'snd       let [x, y] = (λ[x: #Bool] → [5, x]) [#true]; x
test type.let'one       let x = 5; #nat'add [x, x]
test type.let'some      let a = 2; let b = 3; #nat'add [a, b]


-- Do blocks ------------------------------------------------------------------
test type.do'fst
 do {   [x, y] = (λ[x: #Bool] → [x, 5]) [#true];
        x
 }

test type.do'some
 do {   a = 2; b = 3;
        #nat'add [a, b]
 }

test type.do'things
 do {   a       = 2;
        [b, c]  = [2, 3];
        d       = #nat'add [a, b];
        #nat'add [a, #nat'add [b, #nat'add [c, d]]];
 }


-- Records --------------------------------------------------------------------
test type.record'empty  ⟨⟩
test type.record'one    ⟨x = 5⟩
test type.record'two    ⟨x = 5, y = #true⟩
test type.record'three  ⟨x = 5, y = #true, z = #unit⟩


-- Field projections ----------------------------------------------------------
test type.field'one     ⟨x = 5⟩.x
test type.field'two     ⟨x = 5, y = #true⟩.y
test type.field'nest    ⟨x = ⟨x = 5, y = #unit⟩, y = #true⟩.x.y
test type.field'paren   ((⟨x = ⟨x = 5, y = #unit⟩, y = #true⟩).x).y


-- Maybe -----------------------------------------------------------------------
test type.none          #None

test type.list'empty    [list #Nat|]
test type.list'some     [list #Nat| 1, 2, 3]
test type.list'head     #list'head @[#Nat] [list #Nat| 1, 2, 3]
test type.list'tail     #list'tail @[#Nat] [list #Nat| 1, 2, 3]

test type.set'empty     [set #Nat|]
test type.set'some      [set #Nat| 1, 2, 3]
test type.set'size      #set'size @[#Nat] [set #Nat| 1, 2, 3, 4, 5]

