-- Test syntax of procs.
-- TODO: add exec tests to use the bindings.

-- declarations ---------------------------------------------------------------
term decl1 []: []
 = proc yield []

term decl2 [n: #Nat]: #Nat
 = proc yield n

term decl3 [n: #Nat]: [] ! #Console
 = box proc
        seq call #console'print "hello";
        end

term decl4 []: #Nat ! #Console
 = box proc
        seq call #console'print "hello";
        yield [5]


-- sugar for the above.
proc decl1s []: #Nat
 =      yield [4]

proc decl2s [n: #Nat]: []
 =      yield []

-- TODO: if drop effect annotation should get error.
proc decl3s [n: #Nat]: []! #Console
 =      seq call #console'print "hello";
        yield []

proc decl3ss [n: #Nat]: []! #Console
 = do   { call #console'print "hello"
        ; yield [] }

proc decl4s []: #Nat ! #Console
 =      seq call #console'print "hello";
        yield 5

proc decl4ss []: #Nat ! #Console
 = do   { call #console'print "hello"
        ; yield 5 }


-- yield ----------------------------------------------------------------------
term yield1 [x: #Nat]: #Nat
 = proc yield [x]


-- call -----------------------------------------------------------------------
-- TODO: allow 'call' keyword to be implicit.
term call1 [x: #Nat]: #Nat
 = proc call #nat'add [x, x]

term call1s [x: #Nat]: #Nat
 = proc do { call #nat'add [x, x] }


-- sequencing -----------------------------------------------------------------
-- simple sequencing
proc seq0 [x: #Nat, y: #Nat]: #Nat
 =      seq a = yield 2;
        seq b = yield 3;
        yield #nat'add [a, b]

proc seq0s [x: #Nat, y: #Nat]: #Nat
 = do   seq a = yield 2
        seq b = yield 3
        yield #nat'add [a, b]

-- sugar where the vector of bindings is assumed to be empty.
proc seq1 []: []! #Console
 =      seq call #console'print "hello";
        seq call #console'print "world";
        seq call #console'print "derp";
        end

proc seq1s []: []! #Console
 = do   call #console'print ["hello"]
        call #console'print "world"
        call #console'print "derp"

-- nested procedure.
proc seq'nest1 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq call #console'print "world";
            end;
        end

proc seq'nest1s []: []! #Console
 = do   call #console'print "good morning"
        do      call #console'print "hello"
                call #console'print "world"

-- doubly nested procedure.
proc seq'nest2 []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq seq call #console'print "world";
                end;
            end;
        end

-- as above, but with explicit seqs and implicit process end.
proc seq'nest2n []: []! #Console
 =      seq call #console'print "good morning";
        seq seq call #console'print "hello";
            seq seq call #console'print "world"

-- as above, but with explicit do syntax.
proc seq'nest2s []: []! #Console
 = do   { call #console'print "good morning"
        ; do    { call #console'print "hello"
                ; do    { call #console'print "world" }
        }
 }

-- as above, but with implicit do syntax.
proc seq'nest2ss []: []! #Console
 = do   call #console'print "good morning"
        do      call #console'print "hello"
                do      call #console'print "world"


-- cell-introduction ----------------------------------------------------------
-- TODO: allow type to be omitted, like with let bindings
proc cell1 [x: #Nat, y: #Nat]: #Nat
 =      cell a: #Nat ← 4;
        cell b: #Nat ← 5;
        yield #nat'add [a, b]

proc cell1s [x: #Nat, y: #Nat]: #Nat
 = do   cell a: #Nat ← 4
        cell b: #Nat ← 5
        yield #nat'add [a, b]


-- cell update ----------------------------------------------------------------
-- TODO: allow 'update' keyword to be implicit.
proc update1 [x: #Nat, y: #Nat]: #Nat
 =      cell a: #Nat ← x;
        update a ← y;
        yield a

proc update1s [x: #Nat, y: #Nat]: #Nat
 = do   cell a: #Nat ← x
        update a ← y
        yield a


-- when -----------------------------------------------------------------------
proc when1 [b: #Bool, x: #Nat, y: #Nat]: #Nat
 =      when b then return 5 done;
        yield y

proc when1s [b: #Bool, x: #Nat, y: #Nat]: #Nat
 = do   { when b then return 5 done
        ; yield y }


proc when2 [n: #Nat]: #Text ! #Console
 =      when #nat'eq [n, 1] then return "one" done;
        when #nat'eq [n, 2] then return "two" done;
        when #nat'eq [n, 3] then return "three" done;
        yield "dunno"

proc when2s [n: #Nat]: #Text ! #Console
 = do   when #nat'eq [n, 1] then return "one" done
        when #nat'eq [n, 2] then return "two" done
        when #nat'eq [n, 3] then return "three" done
        yield "dunno"


proc whens2s [n: #Nat]: #Text ! #Console
 = do   whens
         #nat'eq [n, 1] → return "one"
         #nat'eq [n, 2] → return "two"
         #nat'eq [n, 3] → return "three"
        yield "dunno"


proc when3 [n: #Nat, m: #Nat]: #Text ! #Console
 =      when #nat'eq [n, 1] then
                when #nat'eq [n, 2] then
                        return "derp"
                done
        done;
        yield "whatever"

proc when3s [n: #Nat, m: #Nat]: #Text ! #Console
 = do   { when #nat'eq [n, 1] then
                when #nat'eq [n, 2] then do
                        { return "derp" }
                done
         done
        ; yield "whatever" }

proc when3ss [n: #Nat, m: #Nat]: #Text ! #Console
 = do   when #nat'eq [n, 1] do
                { when #nat'eq [n, 2] do
                        return "derp"
                }
        yield "whatever"


proc when4 [n: #Nat, m: #Nat]: #Text ! #Console
 =      when #nat'eq [n, 1] then
                when #nat'eq [m, 1] then
                        return "one, one"
                done;
                when #nat'eq [m, 2] then
                        return "one, two"
                done
        done;
        yield "whatever"

proc when4s [n: #Nat, m: #Nat]: #Text ! #Console
 = do   { when #nat'eq [n, 1] then
          do    { when #nat'eq [m, 1] then
                        return "one, one"
                  done
                ; when #nat'eq [m, 2] then
                        return "one, two"
                  done
                }
          done
        ; yield "whatever" }

proc when4ss [n: #Nat, m: #Nat]: #Text ! #Console
 = do   { when #nat'eq [n, 1] do
                { when #nat'eq [m, 1] do
                        { return "one, one" }
                ; when #nat'eq [m, 2] do
                        { return "one, two" }
                }
        ; yield "whatever"
        }

proc when4sss [n: #Nat, m: #Nat]: #Text ! #Console
 = do   when #nat'eq [n, 1] do
                when #nat'eq [m, 1] do
                        return "one, one"
                when #nat'eq [m, 2] do
                        return "one, two"
        yield "whatever"


proc when4ssss [n: #Nat, m: #Nat]: #Text ! #Console
 = do   when #nat'eq [n, 1]
         do     when #nat'eq [m, 1]
                 do     return "one, one"
                when #nat'eq [m, 2]
                 do     return "one, two"
        yield "whatever"


proc when5 [n: #Nat, m: #Nat]: #Text ! #Console
 =      whens { #nat'eq [n, 1]
                → whens { #nat'eq [m, 1] → return "one, one"
                        ; #nat'eq [m, 2] → return "one, two" } };
        yield "whatever"


proc whens5 [n: #Nat, m: #Nat]: #Text ! #Console
 = do   whens #nat'eq [n, 1]
                → whens #nat'eq [m, 1] → return "one, one"
                        #nat'eq [m, 2] → return "one, two"
        yield "whatever"


-- match ----------------------------------------------------------------------
-- match does not need to be exhaustive because if we don't have
-- and alt for the given value we continue to the rest of the procedure.
proc match2 [v: <foo: #Nat, bar: #Nat>]: #Nat
 =      match v with
         { foo [x: #Nat] → return x };
        yield [5]


-- TODO: if the alts are exhaustive then the cont. is dead code,
-- so we shouldn't need to provide the result value.
proc match1 [v: <foo: #Nat, bar: #Nat>]: #Nat
 =      match v with
          { foo [x: #Nat] → return x
          ; bar [x: #Nat] → return x };
         yield [5]


proc match1s [v: <foo: #Nat, bar: #Nat>]: #Nat
 = do   match v with
         foo [x: #Nat] → return x
         bar [x: #Nat] → return x
        yield [5]


proc match3 [v: <foo: #Nat, bar: [#Bool, #Nat, #Nat], baz: #Nat>]: #Nat
 =      match v with
         { foo [x: #Nat] → return x
         ; bar [b: #Bool, x: #Nat, y: #Nat]
           → when b then return x done;
             return y
         ; baz [x: #Nat] → return x };
        yield 0


proc match3s [v: <foo: #Nat, bar: [#Bool, #Nat, #Nat], baz: #Nat>]: #Nat
 = do   { match v with
                { foo [x: #Nat] → return x
                ; bar [b: #Bool, x: #Nat, y: #Nat]
                  → do  { when b do { return x }
                        ; return y
                        }
                ; baz [x: #Nat] → return x }
        ; yield 0 }


proc match3ss [v: <foo: #Nat, bar: [#Bool, #Nat, #Nat], baz: #Nat>]: #Nat
 = do   match v with
         foo [x: #Nat] → return x
         bar [b: #Bool, x: #Nat, y: #Nat]
           → do when b then return x done
                return y
         baz [x: #Nat] → return x

        yield 0


-- loop -----------------------------------------------------------------------
proc loop1 [n: #Nat]: []! #Console
 =      loop    when #nat'gt [n, 10]
                        then return []
                done;
                call #console'print "hello"
        done


proc loop1s [n: #Nat]: []! #Console
 = loop do
        { when #nat'gt [n, 10] do
                { return [] }
        ; call #console'print "hello" }


proc loop1ss [n: #Nat]: []! #Console
 = loop do
        when #nat'gt [n, 10] do
                return []
        call #console'print "hello"


-- proc foo
--  =   enter   start []
--      with  { start [x]    = seq call fac [2, 3]; end
--            ; final []     = leave
--            };
--      seq call derp
--      yield [5]
--
--



